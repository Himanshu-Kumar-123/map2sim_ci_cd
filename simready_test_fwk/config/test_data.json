{
  "test_usd_code_sample_prompts": [
    {
      "prompt": "How to create a new layer?",
      "expected_output": "from pxr import Sdf\n\ndef create_new_layer(layer_name: str) -> Sdf.Layer:\n    \"\"\"Create a new USD layer.\n\n    Args:\n        layer_name (str): The name of the new layer.\n\n    Returns:\n        Sdf.Layer: The newly created layer.\n    \"\"\"\n    new_layer = Sdf.Layer.FindOrOpen(layer_name)\n    if new_layer:\n        return new_layer\n    else:\n        new_layer = Sdf.Layer.CreateNew(layer_name)\n        return new_layer\n\n# Full Usage\nnew_layer_name = \"my_new_layer.usda\"\nnew_layer = create_new_layer(new_layer_name)\nprint(new_layer.identifier)"
    },
    {
      "prompt": "How do I read attributes from a prim?",
      "expected_output": "from pxr import Usd, UsdGeom\n\n# Create an in-memory stage\nstage = Usd.Stage.CreateInMemory()\n\n# Define a BasisCurves prim at the specified path\nbasis_curves_path = '/exampleBasisCurves'\nbasis_curves_prim = UsdGeom.BasisCurves.Define(stage, basis_curves_path)\n\n# Get the attributes of the BasisCurves prim\nfor attr in basis_curves_prim.GetPrim().GetAttributes():\n    print(f\"Attribute: {attr.GetName()}\")"
    },
    {
      "prompt": "Show me how to traverse a stage?",
      "expected_output": "from pxr import Usd, UsdGeom\n\n# Create a new stage in memory\nstage = Usd.Stage.CreateInMemory()\n\n# Define some prims to populate the stage\nroot = stage.DefinePrim('/World', 'Xform')\nroom = stage.DefinePrim('/World/Room', 'Xform')\ntable = stage.DefinePrim('/World/Room/Table', 'Mesh')\nchair = stage.DefinePrim('/World/Room/Chair', 'Mesh')\nlamp = stage.DefinePrim('/World/Room/Lamp', 'Light')\n\n# Traverse all prims in the stage and print their paths\ndef traverse_prims(stage):\n    for prim in stage.Traverse():\n        print(prim.GetPath())\n\n# Call the function to traverse and print all prims\ntraverse_prims(stage)\n\n# Optionally, print the stage contents\nprint(stage.GetRootLayer().ExportToString())"
    }
  ],
  "test_copy_generated_responses": {
      "prompt": "Write python code to convert array of float data from numpy into usd",
      "context": "from pxr import Usd, UsdGeom, Sdf, Vt\nimport numpy as np\n\ndef numpy_array_to_usd(stage, prim_path, attr_name, numpy_array):\n    prim = stage.GetPrimAtPath(prim_path)\n    if not prim:\n        # If the prim does not exist, create it\n        prim = stage.DefinePrim(prim_path, 'Xform')\n    \n    attr = prim.GetAttribute(attr_name)\n    if attr:\n        vt_array = Vt.FloatArray(numpy_array)\n        attr.Set(vt_array)\n    else:\n        attr = prim.CreateAttribute(attr_name, Sdf.ValueTypeNames.FloatArray, custom=True)\n        vt_array = Vt.FloatArray(numpy_array)\n        attr.Set(vt_array)\n\n# Example usage\nstage = Usd.Stage.CreateInMemory()\nprim_path = '/World/MyPrim'\nattr_name = 'myFloatArrayAttr'\nnumpy_array = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n\nnumpy_array_to_usd(stage, prim_path, attr_name, numpy_array)\n\nprint(stage.GetRootLayer().ExportToString())",
      "score": 0.8
  },
  "test_execute_generated_code": {
      "prompt": ["Write a python function that given a layer, reverse the order of the sublayers","Write python code to get the world space position of a prim"]
  },
  "test_basic_queries": [
      {
        "prompt": "What is the difference between usd, usda, and usdz?",
        "context": "USD, USDA, and USDZ are all file formats related to Pixar's Universal Scene Description (USD) framework, which is used for creating, manipulating, and representing 3D scene data.\n\n1. USD: USD is the original acronym for Pixar's Universal Scene Description (OpenUSD) framework. However, in terms of file format, a .usd file can be either in USDA (text, human-readable) format or USDC (binary, efficient for machines to read) format. The USD framework automatically detects the underlying format between USDA and USDC when opening a .usd file.\n\n2. USDA: This is the UTF-8 representation of a USD file. This means it's text-based and can, therefore, easily be read and edited by humans. However, compared to the USDC format, it takes more disk space and requires more computing resources to process. The file extension is .usda.\n\nHere is an example of what .usda file content could look like:\n\n```\n#usda 1.0\ndef \"World\"\n{\n  def Sphere \"MySphere\"\n  {\n    double radius = 1.7\n  }\n}\n```\n\n3. USDC: This is a binary representation of a USD file. It's designed to be machine-readable, which makes it more compact (takes less disk space) and quicker for programs to process than USDA, but it is not human-readable. Less flexible for collaborative editing of the same USDC file. The file extension is .usdc. You can find more information on USDC at https:\/\/openusd.org\/release\/glossary.html#crate-file-format",
        "score": 0.9
      },
      {
        "prompt": "What's the difference between an attribute and a relationship?",
        "context": "An attribute and a relationship in USD (Universal Scene Description) are both types of property and serve distinct roles:\n\n1. **Attribute**:\nAttributes are the most common type of property authored in most USD scenes. An attribute can hold a variety of typed data (e.g., integers, floats, strings, etc.), including complex types like arrays. It can have a single value or a series of values over time. Attributes are typically used to store data such as transformation matrices, colors, texture paths, etc.\n\n2. **Relationship**:\nA relationship, on the other hand, is a path targeting other objects (prims, attributes, or other relationships) associating different components within the scene graph. They robustly identify other scene objects and are used to establish dependencies between prims as a whole, or the dependency of a prim as a whole upon a targeted property.\n\n\nSee \u201CWhat are Properties?\u201D in https:\/\/aousd.org\/blog\/explainer-series-what-is-openusd\/ for more information.\n",
        "score": 0.9
      },
      {
        "prompt": "What is a Hydra Scene Delegate?",
        "context": "Hydra is a component of the USD (Universal Scene Description) system from Pixar. It's an important part of USD\u00E2\u20AC\u2122s architecture system and serves as a system for preview and rendering product solutions.\n\nA Hydra Scene Delegate or `HdSceneDelegate` is a key class in Hydra's architecture. It acts as a bridge between Hydra's renderer-agnostic scene graph (`HdRenderIndex`) and client scene graph (which may be a USD stage, or other scene description).\n\nScene delegates are responsible to map scene data of client's scene graph to Hydra's scene, providing Hydra (or attached Hydra rendering plugins) with access to necessary scene data. They essentially handle translation and synchronization of data between the client's scene graph and Hydra's scene.\n\nThere\u00E2\u20AC\u2122re several key responsibilities of a scene delegate:\n1. Translating data: It's expected to translate geometric and shading data from the client application to Hydra. The types of data needing translation include but not limited to transformation matrices, materials, lights, cameras etc.\n2. Synchronization: It's responsible for synchronizing change updates from the client's scene graph to the Hydra's scene graph.\n3. Resolving computations: If there are any computed values in the client's scene graph, they need to be efficiently resolved.\n4. Instancing: The scene delegate determines the instancing of objects in the Hydra scene.\n\nThe ultimate goal of the scene delegate is making sure the `HdRenderIndex` (Hydra's scene) is correctly populated and updated with data, so that the rendering plugins can do their job and render the scene accordingly.\n\nThis base class (HdSceneDelegate) provides a simple, default implementation of a scene delegate, but it is typical for apps to create a subclass that communicates with its specific scene graph.\n\nThe details on how to use or override specific methods can be found in the official documentation of USD: https:\/\/graphics.pixar.com\/usd\/docs\/api\/class_hd_scene_delegate.html\n",
        "score": 0.8
      },
      {
        "prompt": "When should I use SubLayers vs References in USD?",
        "context": "The decision to use SubLayers or References in Universal Scene Description (USD) will depend on both the content of your layers and what you need to do with the resulting composition. Here are some key considerations:\n\n1. Choosing SubLayers could be advantageous due to its simplicity. They result in more compact runtime data structures and more efficient value resolution. Layer muting and choosing layers to edit via Edit Targets are also more straightforward with SubLayers.\n\n2. SubLayering might not be suitable if the layers do not share the same namespace. Sublayering overlays different namespaces without any renaming possibilities. Conversely, References allow you to remap specific prims into a different namespace.\n\n3. If your layers contain root prims that you don't want exposed in the resulting composition, References could again be more suitable. References allow more specific control since you can target specific prims within a layer.\n\n4. However, if you need to add VariantSets that override the result of your composition, you will need to reference your results together instead of SubLayering them. Any VariantSet data will be weaker than the data in your SubLayers, so if you want the VariantSet data to override, you would need to use References.\n\nHere are examples to show basic SubLayering and References:\n\nSubLayering:\n\n```python\n#usda 1.0\n(\nsubLayers = [\n\"shotFX.usd\",\n\"shotAnimationBake.usd\",\n\"sequence.usd\"\n]\n)\n```\n\nReferences:\n\n```python\n#usda 1.0\ndef \"MyPrim\"(\nreferences = [\n\"sequence.usd\"\n]\n)\n```\n\nRemember that each of the above methods serves different purposes and has its own strengths and weaknesses. You should choose based on the specific requirements of your project.\n\n",
        "score": 0.9
      },
      {
        "prompt": "What is usdcat used for?",
        "context": "`usdcat` is a command-line tool provided by the Universal Scene Description (USD) for handling USD files. It is primarily utilized for the following purposes:\n\n1. **Read USD files**: `usdcat` can be used to read USD files and write the content either as text to stdout (standard output, typically the terminal) or to a specified output file.\n\n2. **Data conversion**: The tool can convert files between USD's different file formats (i.e., `.usda` (ASCII), `.usdc` (Binary), and `.usd` (can be either)). This conversion can be achieved by specifying an output filename with the desired extension or by using the `--usdFormat` option.\n\n3. **Flatten USD files**: `usdcat` also has the ability to \"flatten\" the contents of a USD file. Flattening refers to the process of resolving all the references, sublayers, and variants into a single layer, hence making a self-contained file. The flattened content can be written to stdout or another file by applying the `--flatten` or `--flattenLayerStack` options.\n\n4. **Masking prims**: With `--mask` option, the tool can limit the stage population to specific prims, including their descendants and ancestors.\n\n5. **Load file validation**: By using the `--loadOnly` flag, you can instruct `usdcat` to merely attempt to load the specified input files and report 'OK' or 'ERR' for each one. This is useful when you want to check if a set of files are correctly formatted and load without issues.\n\nHere is an example usage of usdcat:\n\n```\nusdcat -o output.usdc input.usda\n```\nIn this example, usdcat is reading 'input.usda' (which is in text format) and converting it into 'output.usdc' (which is in binary format).",
        "score": 0.9
      }
    ],
    "test_usd_code_commenting": [
      {
        "prompt": "Add appropriate comments to following code:\n\nfrom pxr import Usd, UsdGeom, Gf\n\nstage = Usd.Stage.CreateInMemory()\n\nmesh_prim_path = '\/World\/Mesh'\nmesh_prim = UsdGeom.Mesh.Define(stage, mesh_prim_path)\n\npoints = [Gf.Vec3f(0, 0, 0), Gf.Vec3f(1, 0, 0), Gf.Vec3f(1, 1, 0), Gf.Vec3f(0, 1, 0)]\nmesh_prim.CreatePointsAttr(points)\n\nxform_cache = UsdGeom.XformCache()\n\nmesh_prim = stage.GetPrimAtPath(mesh_prim_path)\nworld_transform = xform_cache.GetLocalToWorldTransform(mesh_prim)\n\nworld_points = []\nfor point in points:\n    world_point = world_transform.Transform(Gf.Vec3d(point))\n    world_points.append(world_point)\n\nprint(\"Original points:\")\nfor point in points:\n    print(point)\n\nprint(\"\\nWorld space points:\")\nfor point in world_points:\n    print(point)",
        "expected_output": "```from pxr import Usd, UsdGeom, Gf\n\n# Create an in-memory USD stage\nstage = Usd.Stage.CreateInMemory()\n\n# Define a mesh prim at the path '\/World\/Mesh'\nmesh_prim_path = '\/World\/Mesh'\nmesh_prim = UsdGeom.Mesh.Define(stage, mesh_prim_path)\n\n# Create a list of points for the mesh\npoints = [\n    Gf.Vec3f(0, 0, 0),  # point 1\n    Gf.Vec3f(1, 0, 0),  # point 2\n    Gf.Vec3f(1, 1, 0),  # point 3\n    Gf.Vec3f(0, 1, 0)   # point 4\n]\n\n# Create a points attribute on the mesh prim and set its value to the points list\nmesh_prim.CreatePointsAttr(points)\n\n# Create an XformCache object to compute the world-space transform of the mesh prim\nxform_cache = UsdGeom.XformCache()\n\n# Get the mesh prim from the stage using its path\nmesh_prim = stage.GetPrimAtPath(mesh_prim_path)\n\n# Compute the world-space transform of the mesh prim\nworld_transform = xform_cache.GetLocalToWorldTransform(mesh_prim)\n\n# Create a list to store the world-space points\nworld_points = []\n\n# Iterate over the original points and transform them to world space\nfor point in points:\n    world_point = world_transform.Transform(Gf.Vec3d(point))\n    world_points.append(world_point)\n\n# Print the original points\nprint(\"Original points:\")\nfor point in points:\n    print(point)\n\n# Print the world-space points\nprint(\"\\nWorld space points:\")\nfor point in world_points:\n    print(point)```"
      },
      {
        "prompt": "Add appropriate comments to following code:\n\nfrom pxr import Sdf\n\ndef make_weakest_sublayer_strongest(layer):\n    \"\"\"Make the weakest sublayer the strongest if the layer has more than one sublayer.\"\"\"\n    if len(layer.subLayerPaths) > 1:\n        weakest_sublayer = layer.subLayerPaths[-1]\n        layer.subLayerPaths.remove(weakest_sublayer)\n        layer.subLayerPaths.insert(0, weakest_sublayer)\n\n\nlayer = Sdf.Layer.CreateAnonymous()\nsublayer1 = Sdf.Layer.CreateAnonymous()\nsublayer2 = Sdf.Layer.CreateAnonymous()\nsublayer3 = Sdf.Layer.CreateAnonymous()\n\nlayer.subLayerPaths.append(\"sublayer1.usda\")\nlayer.subLayerPaths.append(\"sublayer2.usda\")\nlayer.subLayerPaths.append(\"sublayer3.usda\")\n\nmake_weakest_sublayer_strongest(layer)\nprint(layer.subLayerPaths) \n",
        "expected_output": "```from pxr import Sdf\n\ndef make_weakest_sublayer_strongest(layer):\n    \"\"\"Make the weakest sublayer the strongest if the layer has more than one sublayer.\"\"\"\n    # Check if the layer has more than one sublayer\n    if len(layer.subLayerPaths) > 1:\n        # Get the weakest sublayer (last one in the list)\n        weakest_sublayer = layer.subLayerPaths[-1]\n        # Remove the weakest sublayer from the list\n        layer.subLayerPaths.remove(weakest_sublayer)\n        # Insert the weakest sublayer at the beginning of the list to make it the strongest\n        layer.subLayerPaths.insert(0, weakest_sublayer)\n\n# Create an anonymous layer\nlayer = Sdf.Layer.CreateAnonymous()\n\n# Create anonymous sublayers\nsublayer1 = Sdf.Layer.CreateAnonymous()\nsublayer2 = Sdf.Layer.CreateAnonymous()\nsublayer3 = Sdf.Layer.CreateAnonymous()\n\n# Add sublayers to the layer\nlayer.subLayerPaths.append(\"sublayer1.usda\")\nlayer.subLayerPaths.append(\"sublayer2.usda\")\nlayer.subLayerPaths.append(\"sublayer3.usda\")\n\n# Call the function to make the weakest sublayer the strongest\nmake_weakest_sublayer_strongest(layer)\n\n# Print the updated sublayer paths\nprint(layer.subLayerPaths)\n```"
      }
    ],
    "test_usd_code_correction": [
      {
        "prompt" :"Check following code and make corrections if required:\nfrom pxr import Usd, UsdGeom, Gf\n\n# Create a stage\nstage = Usd.Stage.CreateInMemory()\n\n# Define a mesh prim\nmesh_prim_path = '/World/Mesh'\nmesh_prim = UsdGeom.Mesh.Define(stage, mesh_prim_path)\n\n# Create some sample mesh points\npoints = [Gf.Vec3f(0, 0, 0), Gf.Vec3f(1, 0, 0), Gf.Vec3f(1, 1, 0), Gf.Vec3f(0, 1, 0)]\nmesh_prim.CreatePointsAttr(points)\n\n# Create an XformCache\nxform_cache = UsdGeom.XformCache()\n\n# Get the world space transform for the mesh\nmesh_prim = stage.GetPrimAtPath(mesh_prim_path)\nworld_transform = xform_cache.GetLocalToWorldTransform(mesh_prim.GetPrim())\n\n# Transform mesh points to world space\nworld_points = []\nfor point in points:\n    world_point = world_transform.Transform(point, Gf.Vec3f(1, 1, 1))\n    world_points.append(world_point)\n\n# Print the original and world space points\nprint(\"Original points:\")\nfor point in points:\n    print(point)\n\nprint(\"\nWorld space points:\")\nfor point in world_points:\n    print(point)",
        "expected_output": "```from pxr import Usd, UsdGeom, Gf, Vt\r\n\r\n# Create a stage\r\nstage = Usd.Stage.CreateInMemory()\r\n\r\n# Define a mesh prim\r\nmesh_prim_path = '\/World\/Mesh'\r\nmesh_prim = UsdGeom.Mesh.Define(stage, mesh_prim_path)\r\n\r\n# Create some sample mesh points\r\npoints = [Gf.Vec3f(0, 0, 0), Gf.Vec3f(1, 0, 0), Gf.Vec3f(1, 1, 0), Gf.Vec3f(0, 1, 0)]\r\nmesh_prim.CreatePointsAttr(Vt.Vec3fArray(points))\r\n\r\n# Create an XformCache\r\nxform_cache = UsdGeom.XformCache()\r\n\r\n# Get the world space transform for the mesh\r\nmesh_prim = stage.GetPrimAtPath(mesh_prim_path)\r\nworld_transform = xform_cache.GetLocalToWorldTransform(mesh_prim)\r\n\r\n# Transform mesh points to world space\r\nworld_points = []\r\nfor point in points:\r\n    world_point = world_transform.Transform(point)\r\n    world_points.append(world_point)\r\n\r\n# Print the original and world space points\r\nprint(\"Original points:\")\r\nfor point in points:\r\n    print(point)\r\n\r\nprint(\"\\nWorld space points:\")\r\nfor point in world_points:\r\n    print(point)\r\n```"
      },
      {
        "prompt": "check following code and make corrections if required:\n\nfrom pxr import Usd, UsdGeom, Gf, Sdf\n\n# Create a new stage\nstage = Usd.Stage.CreateInMemory()\n\n# Define a cube on the stage\ncube_prim = UsdGeom.Cube.Define(stage, '\\/MyCube')\n\n# Create a primvar for the UVs\nuv_set = UsdGeom.PrimvarsAPI(cube_prim).CreatePrimvar('st', Sdf.ValueTypeNames.TexCoord2fArray)\n\n# Define the UV coordinates for each face of the cube\nuvs = [\n    # Front face (UDIM 1001)\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\n    # Back face (UDIM 1002)\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\n    # Left face (UDIM 1003)\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\n    # Right face (UDIM 1004)\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\n    # Top face (UDIM 1005)\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\n    # Bottom face (UDIM 1006)\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0)\n]\n\n# Set the UV values\nuv_set.Set(uvs)\n\n# Set the interpolation for the UV primvar\nuv_set.SetInterpolation(UsdGeom.Tokens.faceVarying)\n\n# Print the resulting USD stage as ASCII\nprint(stage.GetRootLayer().ExportToString())",
        "expected_output": "```from pxr import Usd, UsdGeom, Gf, Sdf\r\n\r\n# Create a new stage\r\nstage = Usd.Stage.CreateInMemory()\r\n\r\n# Define a cube on the stage\r\ncube_prim = UsdGeom.Cube.Define(stage, '\/MyCube')\r\n\r\n# Create a primvar for the UVs\r\nuv_set = UsdGeom.PrimvarsAPI(cube_prim).CreatePrimvar('st', Sdf.ValueTypeNames.TexCoord2fArray)\r\n\r\n# Define the UV coordinates for each face of the cube\r\nuvs = [\r\n    # Front face (UDIM 1001)\r\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\r\n    # Back face (UDIM 1002)\r\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\r\n    # Left face (UDIM 1003)\r\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\r\n    # Right face (UDIM 1004)\r\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\r\n    # Top face (UDIM 1005)\r\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\r\n    # Bottom face (UDIM 1006)\r\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0)\r\n]\r\n\r\n# Set the UV values\r\nuv_set.Set(uvs)\r\n\r\n# Set the interpolation for the UV primvar\r\nuv_set.SetInterpolation(UsdGeom.Tokens.faceVarying)\r\n\r\n# Print the resulting USD stage as ASCII\r\nprint(stage.GetRootLayer().ExportToString())\r\n```"
      }
    ],
    "test_usd_code_generation": [
      {
        "prompt": "Write a python function that given a Usd.Prim object, it creates a variant set on that prim called \"colors\" with three variants: \"red\", \"blue\", and \"green\". The variants should set the displayColor primvar on the prim to the colors red, blue, and green respectively.",
        "expected_output": "```from pxr import Usd, UsdGeom, Sdf, Gf\n\ndef create_color_variants(prim: Usd.Prim) -> None:\n    \"\"\"Create a variant set on a USD prim with three variants: \"red\", \"blue\", and \"green\".\n    \n    The variants set the displayColor primvar on the prim to the corresponding colors.\n    \"\"\"\n    variant_set_spec = prim.GetVariantSet('colors')\n    if not variant_set_spec:\n        variant_set_spec = prim.DefineVariantSet('colors')\n\n    # Create variants\n    variant_set_spec.AddVariant('red')\n    variant_set_spec.AddVariant('blue')\n    variant_set_spec.AddVariant('green')\n\n    # Set displayColor primvar for each variant\n    variant_set_spec.SetVariantSelection('red')\n    prim.CreateAttribute('displayColor', Sdf.ValueTypeNames.Color3f).Set(Gf.Vec3f(1.0, 0.0, 0.0))  # Red\n\n    variant_set_spec.SetVariantSelection('blue')\n    prim.CreateAttribute('displayColor', Sdf.ValueTypeNames.Color3f).Set(Gf.Vec3f(0.0, 0.0, 1.0))  # Blue\n\n    variant_set_spec.SetVariantSelection('green')\n    prim.CreateAttribute('displayColor', Sdf.ValueTypeNames.Color3f).Set(Gf.Vec3f(0.0, 1.0, 0.0))  # Green\n\n# Example usage:\nstage = Usd.Stage.CreateInMemory()\nprim = stage.DefinePrim('/MyPrim', 'Xform')\ncreate_color_variants(prim)\nprint(stage.ExportToString())```",
        "verify": ["MyPrim"]
      },
      {
        "prompt": "Write code to create a three point lighting setup about the scene origin using disk lights. All of the lights should be oriented to light a subject at the origin of the scene.",
        "expected_output": "```from pxr import Usd, UsdLux, UsdGeom, Gf, Sdf\n\n# Create an in-memory stage\nstage = Usd.Stage.CreateInMemory()\n\n# Define the three disk lights\nkey_light_path = '/Scene/Lighting/KeyLight'\nkey_light = UsdLux.DiskLight.Define(stage, key_light_path)\nkey_light.GetIntensityAttr().Set(1000)\nkey_light.GetColorAttr().Set((1.0, 1.0, 1.0))\n\nfill_light_path = '/Scene/Lighting/FillLight'\nfill_light = UsdLux.DiskLight.Define(stage, fill_light_path)\nfill_light.GetIntensityAttr().Set(500)\nfill_light.GetColorAttr().Set((0.5, 0.5, 0.5))\n\nback_light_path = '/Scene/Lighting/BackLight'\nback_light = UsdLux.DiskLight.Define(stage, back_light_path)\nback_light.GetIntensityAttr().Set(200)\nback_light.GetColorAttr().Set((0.2, 0.2, 0.2))\n\n# Position and orient the lights\nxform_key = UsdGeom.Xformable(key_light)\nxform_key.AddTranslateOp().Set(Gf.Vec3d(2, 2, 2))\nxform_key.AddOrientOp().Set(Gf.Quatf(0, 0, 1, 1))  # Oriented towards the origin\n\nxform_fill = UsdGeom.Xformable(fill_light)\nxform_fill.AddTranslateOp().Set(Gf.Vec3d(-2, 2, 2))\nxform_fill.AddOrientOp().Set(Gf.Quatf(-1, 1, 1, 1))  # Oriented towards the origin\n\nxform_back = UsdGeom.Xformable(back_light)\nxform_back.AddTranslateOp().Set(Gf.Vec3d(0, -2, 2))\nxform_back.AddOrientOp().Set(Gf.Quatf(0, -1, 1, 1))  # Oriented towards the origin\n\n# Print the resulting stage to verify the three-point lighting setup\nprint(stage.GetRootLayer().ExportToString())```",
        "verify": ["KeyLight","FillLight","BackLight"],
        "verify_coord":[
          {"translate": {"x": 2.0, "y": 2.0, "z": 2.0}, "rotate": {"x": 90.0, "y": 6.824688451628931e-15, "z": 180.0}},
          {"translate": {"x": -2.0, "y": 2.0, "z": 2.0}, "rotate": {"x": 0.0, "y": -0.0, "z": 0.0}},
          {"translate": {"x": 0.0, "y": -2.0, "z": 2.0}, "rotate": {"x": 116.56504821777344, "y": 41.8103141784668, "z": -116.56504821777344}}
        ]
      },
      {
        "prompt": "Write python function that given a Usd.Prim object, get the bound material of that prim.",
        "expected_output": "```from pxr import Usd, UsdShade\r\n\r\ndef get_bound_material(prim: Usd.Prim) -> UsdShade.Material:\r\n    \"\"\"Get the bound material of a USD prim\"\"\"\r\n    material_binding_api = UsdShade.MaterialBindingAPI(prim)\r\n    if material_binding_api:\r\n        direct_binding = material_binding_api.GetDirectBinding()\r\n        if direct_binding:\r\n            return direct_binding.GetMaterial()\r\n    return None\r\n\r\n# Example usage:\r\nstage = Usd.Stage.CreateInMemory('HelloWorld.usda')\r\nmy_prim_path = '\/MyPrim'\r\nmy_prim = stage.DefinePrim(my_prim_path, 'Mesh')\r\nmaterial_path = '\/MyMaterial'\r\nmaterial = UsdShade.Material.Define(stage, material_path)\r\nmaterial_binding_api = UsdShade.MaterialBindingAPI.Apply(my_prim)\r\nmaterial_binding_api.Bind(material)\r\nbound_material = get_bound_material(my_prim)\r\nprint(bound_material)\r\n```",
        "verify": ["UsdShade.Material(Usd.Prim(</MyMaterial>))"]
      },
      {
        "prompt": "Write python code to find all of the mesh prims on a stage and make them polygonal meshes instead of subdiv",
        "expected_output": "```from pxr import Usd, UsdGeom\n\ndef convert_mesh_prims_to_polygonal(stage: Usd.Stage) -> None:\n    \"\"\"Convert all mesh prims on a stage to polygonal meshes.\"\"\"\n    for prim in stage.Traverse():\n        if prim.IsA(UsdGeom.Mesh):\n            mesh = UsdGeom.Mesh(prim)\n            mesh.GetSubdivisionSchemeAttr().Set(UsdGeom.Tokens.none)\n\n# Create a stage in memory\nstage = Usd.Stage.CreateInMemory()\n\n# Define some mesh prims to populate the stage\nroot = stage.DefinePrim('/World', 'Xform')\nmesh1 = stage.DefinePrim('/World/Mesh1', 'Mesh')\nmesh2 = stage.DefinePrim('/World/Mesh2', 'Mesh')\n\n# Convert all mesh prims to polygonal meshes\nconvert_mesh_prims_to_polygonal(stage)\n\n# Print the entire stage to USD format to verify the structure\nprint(stage.ExportToString())\n```",
        "verify" : ["Mesh1","Mesh2"]
      }
    ],
    "test_prompts_not_related_to_openusd": [
      {
        "prompt": "How to setup a POST api using FastAPI?",
        "expected_output": "I'm great at USD topics, but for other questions, you should use other models on the NVIDIA API Catalog. I can only answer USD-related questions",
        "context": "The model is only able to answer questions that are directly related to Pixar's Universal Scene Description (USD) and OpenUSD. The FastAPI is not related to these topics."
      },
      {
        "prompt": "How to setup AWS client on a Linux system.",
        "expected_output": "I'm great at USD topics, but for other questions, you should use other models on the NVIDIA API Catalog. I can only answer USD-related questions",
        "context": "The model is only able to answer questions that are directly related to Pixar's Universal Scene Description (USD) and OpenUSD. Setting up AWS client is not related to these topics."
      }
    ],
    "test_usdcode_code_commenting": [
      {
        "prompt": "Add appropriate comments to following code:\n\nfrom pxr import Usd, UsdGeom, Gf\n\nstage = Usd.Stage.CreateInMemory()\n\nmesh_prim_path = '\/World\/Mesh'\nmesh_prim = UsdGeom.Mesh.Define(stage, mesh_prim_path)\n\npoints = [Gf.Vec3f(0, 0, 0), Gf.Vec3f(1, 0, 0), Gf.Vec3f(1, 1, 0), Gf.Vec3f(0, 1, 0)]\nmesh_prim.CreatePointsAttr(points)\n\nxform_cache = UsdGeom.XformCache()\n\nmesh_prim = stage.GetPrimAtPath(mesh_prim_path)\nworld_transform = xform_cache.GetLocalToWorldTransform(mesh_prim)\n\nworld_points = []\nfor point in points:\n    world_point = world_transform.Transform(Gf.Vec3d(point))\n    world_points.append(world_point)\n\nprint(\"Original points:\")\nfor point in points:\n    print(point)\n\nprint(\"\\nWorld space points:\")\nfor point in world_points:\n    print(point)",
        "expected_output": "```from pxr import Usd, UsdGeom, Gf\n\n# Create an in-memory USD stage\nstage = Usd.Stage.CreateInMemory()\n\n# Define a mesh prim at the path '\/World\/Mesh'\nmesh_prim_path = '\/World\/Mesh'\nmesh_prim = UsdGeom.Mesh.Define(stage, mesh_prim_path)\n\n# Create a list of points for the mesh\npoints = [\n    Gf.Vec3f(0, 0, 0),  # point 1\n    Gf.Vec3f(1, 0, 0),  # point 2\n    Gf.Vec3f(1, 1, 0),  # point 3\n    Gf.Vec3f(0, 1, 0)   # point 4\n]\n\n# Create a points attribute on the mesh prim and set its value to the points list\nmesh_prim.CreatePointsAttr(points)\n\n# Create an XformCache object to compute the world-space transform of the mesh prim\nxform_cache = UsdGeom.XformCache()\n\n# Get the mesh prim from the stage using its path\nmesh_prim = stage.GetPrimAtPath(mesh_prim_path)\n\n# Compute the world-space transform of the mesh prim\nworld_transform = xform_cache.GetLocalToWorldTransform(mesh_prim)\n\n# Create a list to store the world-space points\nworld_points = []\n\n# Iterate over the original points and transform them to world space\nfor point in points:\n    world_point = world_transform.Transform(Gf.Vec3d(point))\n    world_points.append(world_point)\n\n# Print the original points\nprint(\"Original points:\")\nfor point in points:\n    print(point)\n\n# Print the world-space points\nprint(\"\\nWorld space points:\")\nfor point in world_points:\n    print(point)```"
      },
      {
        "prompt": "Add appropriate comments to following code:\n\nfrom pxr import Sdf\n\ndef make_weakest_sublayer_strongest(layer):\n    \"\"\"Make the weakest sublayer the strongest if the layer has more than one sublayer.\"\"\"\n    if len(layer.subLayerPaths) > 1:\n        weakest_sublayer = layer.subLayerPaths[-1]\n        layer.subLayerPaths.remove(weakest_sublayer)\n        layer.subLayerPaths.insert(0, weakest_sublayer)\n\n\nlayer = Sdf.Layer.CreateAnonymous()\nsublayer1 = Sdf.Layer.CreateAnonymous()\nsublayer2 = Sdf.Layer.CreateAnonymous()\nsublayer3 = Sdf.Layer.CreateAnonymous()\n\nlayer.subLayerPaths.append(\"sublayer1.usda\")\nlayer.subLayerPaths.append(\"sublayer2.usda\")\nlayer.subLayerPaths.append(\"sublayer3.usda\")\n\nmake_weakest_sublayer_strongest(layer)\nprint(layer.subLayerPaths) \n",
        "expected_output": "```from pxr import Sdf\n\ndef make_weakest_sublayer_strongest(layer):\n    \"\"\"Make the weakest sublayer the strongest if the layer has more than one sublayer.\"\"\"\n    # Check if the layer has more than one sublayer\n    if len(layer.subLayerPaths) > 1:\n        # Get the weakest sublayer (last one in the list)\n        weakest_sublayer = layer.subLayerPaths[-1]\n        # Remove the weakest sublayer from the list\n        layer.subLayerPaths.remove(weakest_sublayer)\n        # Insert the weakest sublayer at the beginning of the list to make it the strongest\n        layer.subLayerPaths.insert(0, weakest_sublayer)\n\n# Create an anonymous layer\nlayer = Sdf.Layer.CreateAnonymous()\n\n# Create anonymous sublayers\nsublayer1 = Sdf.Layer.CreateAnonymous()\nsublayer2 = Sdf.Layer.CreateAnonymous()\nsublayer3 = Sdf.Layer.CreateAnonymous()\n\n# Add sublayers to the layer\nlayer.subLayerPaths.append(\"sublayer1.usda\")\nlayer.subLayerPaths.append(\"sublayer2.usda\")\nlayer.subLayerPaths.append(\"sublayer3.usda\")\n\n# Call the function to make the weakest sublayer the strongest\nmake_weakest_sublayer_strongest(layer)\n\n# Print the updated sublayer paths\nprint(layer.subLayerPaths)\n```"
      }
    ],
    "test_code_correction": [
      {
        "prompt": "check following code and make corrections if required:\n\nfrom pxr import Usd, UsdGeom, Gf\n\n# Create a stage\nstage = Usd.Stage.CreateInMemory()\n\n# Define a mesh prim\nmesh_prim_path = '/World/Mesh'\nmesh_prim = UsdGeom.Mesh.Define(stage, mesh_prim_path)\n\n# Create some sample mesh points\npoints = [Gf.Vec3f(0, 0, 0), Gf.Vec3f(1, 0, 0), Gf.Vec3f(1, 1, 0), Gf.Vec3f(0, 1, 0)]\nmesh_prim.CreatePointsAttr(points)\n\n# Create an XformCache\nxform_cache = UsdGeom.XformCache()\n\n# Get the world space transform for the mesh\nmesh_prim = stage.GetPrimAtPath(mesh_prim_path)\nworld_transform = xform_cache.GetLocalToWorldTransform(mesh_prim.GetPrim())\n\n# Transform mesh points to world space\nworld_points = []\nfor point in points:\n    world_point = world_transform.Transform(point, Gf.Vec3f(1, 1, 1)) \n    world_points.append(world_point)\n\n# Print the original and world space points\nprint(\"Original points:\")\nfor point in points:\n    print(point)\n\nprint(\"\nWorld space points:\")\nfor point in world_points:\n    print(point)",          
        "expected_output": "```from pxr import Usd, UsdGeom, Gf, Vt\r\n\r\n# Create a stage\r\nstage = Usd.Stage.CreateInMemory()\r\n\r\n# Define a mesh prim\r\nmesh_prim_path = '\/World\/Mesh'\r\nmesh_prim = UsdGeom.Mesh.Define(stage, mesh_prim_path)\r\n\r\n# Create some sample mesh points\r\npoints = [Gf.Vec3f(0, 0, 0), Gf.Vec3f(1, 0, 0), Gf.Vec3f(1, 1, 0), Gf.Vec3f(0, 1, 0)]\r\nmesh_prim.CreatePointsAttr(Vt.Vec3fArray(points))\r\n\r\n# Create an XformCache\r\nxform_cache = UsdGeom.XformCache()\r\n\r\n# Get the world space transform for the mesh\r\nmesh_prim = stage.GetPrimAtPath(mesh_prim_path)\r\nworld_transform = xform_cache.GetLocalToWorldTransform(mesh_prim)\r\n\r\n# Transform mesh points to world space\r\nworld_points = []\r\nfor point in points:\r\n    world_point = world_transform.Transform(point)\r\n    world_points.append(world_point)\r\n\r\n# Print the original and world space points\r\nprint(\"Original points:\")\r\nfor point in points:\r\n    print(point)\r\n\r\nprint(\"\\nWorld space points:\")\r\nfor point in world_points:\r\n    print(point)\r\n```",
        "verify":["Original points:","(0, 0, 0)", "(1, 0, 0)", "(1, 1, 0)", "(0, 1, 0)", "", "World space points:", "(0, 0, 0)", "(1, 0, 0)", "(1, 1, 0)", "(0, 1, 0)" ]
      },
      {
        "prompt": "check following code and make corrections if required:\n\nfrom pxr import Usd, UsdGeom, Gf, Sdf\n\n# Create a new stage\nstage = Usd.Stage.CreateInMemory()\n\n# Define a cube on the stage\ncube_prim = UsdGeom.Cube.Define(stage, '/MyCube')\n\n# Create a primvar for the UVs\nuv_set = UsdGeom.PrimvarsAPI(cube_prim).CreatePrimvar('st', Sdf.ValueTypeNames.TexCoord2fArray)\n\n# Define the UV coordinates for each face of the cube\nuvs = [\n    # Front face (UDIM 1001)\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\n    # Back face (UDIM 1002)\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\n    # Left face (UDIM 1003)\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\n    # Right face (UDIM 1004)\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\n    # Top face (UDIM 1005)\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\n    # Bottom face (UDIM 1006)\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0)\n]\n\n# Set the UV values\nuv_set.Set(uvs)\n\n# Set the interpolation for the UV primvar\nuv_set.SetInterpolation(UsdGeom.Tokens.faceVarying)\n\n# Print the resulting USD stage as ASCII\nprint(stage.GetRootLayer().ExportToString())",
        "expected_output": "```from pxr import Usd, UsdGeom, Gf, Sdf\r\n\r\n# Create a new stage\r\nstage = Usd.Stage.CreateInMemory()\r\n\r\n# Define a cube on the stage\r\ncube_prim = UsdGeom.Cube.Define(stage, '\/MyCube')\r\n\r\n# Create a primvar for the UVs\r\nuv_set = UsdGeom.PrimvarsAPI(cube_prim).CreatePrimvar('st', Sdf.ValueTypeNames.TexCoord2fArray)\r\n\r\n# Define the UV coordinates for each face of the cube\r\nuvs = [\r\n    # Front face (UDIM 1001)\r\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\r\n    # Back face (UDIM 1002)\r\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\r\n    # Left face (UDIM 1003)\r\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\r\n    # Right face (UDIM 1004)\r\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\r\n    # Top face (UDIM 1005)\r\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0),\r\n    # Bottom face (UDIM 1006)\r\n    Gf.Vec2f(0.0, 0.0), Gf.Vec2f(1.0, 0.0), Gf.Vec2f(1.0, 1.0), Gf.Vec2f(0.0, 1.0)\r\n]\r\n\r\n# Set the UV values\r\nuv_set.Set(uvs)\r\n\r\n# Set the interpolation for the UV primvar\r\nuv_set.SetInterpolation(UsdGeom.Tokens.faceVarying)\r\n\r\n# Print the resulting USD stage as ASCII\r\nprint(stage.GetRootLayer().ExportToString())\r\n```",
        "verify":["#usda 1.0","def Cube \"MyCube\"","texCoord2f[] primvars:st = [(0, 0), (1, 0), (1, 1), (0, 1), (0, 0), (1, 0), (1, 1), (0, 1), (0, 0), (1, 0), (1, 1), (0, 1), (0, 0), (1, 0), (1, 1), (0, 1), (0, 0), (1, 0), (1, 1), (0, 1), (0, 0), (1, 0), (1, 1), (0, 1)] (","interpolation = \"faceVarying\""]
      }
    ],
    "test_basic_queries_knowledge_follow_up": [
      {
        "prompts": [
          "What are Sublayers?",
          "What are References?"
        ],
        "follow_up": "When should I use either of them?",
        "follow_up_context": "The decision to use SubLayers or References in Universal Scene Description (USD) will depend on both the content of your layers and what you need to do with the resulting composition. Here are some key considerations:\n\n1. Choosing SubLayers could be advantageous due to its simplicity. They result in more compact runtime data structures and more efficient value resolution. Layer muting and choosing layers to edit via Edit Targets are also more straightforward with SubLayers.\n\n2. SubLayering might not be suitable if the layers do not share the same namespace. Sublayering overlays different namespaces without any renaming possibilities. Conversely, References allow you to remap specific prims into a different namespace.\n\n3. If your layers contain root prims that you don't want exposed in the resulting composition, References could again be more suitable. References allow more specific control since you can target specific prims within a layer.\n\n4. However, if you need to add VariantSets that override the result of your composition, you will need to reference your results together instead of SubLayering them. Any VariantSet data will be weaker than the data in your SubLayers, so if you want the VariantSet data to override, you would need to use References.\n\nHere are examples to show basic SubLayering and References:\n\nSubLayering:\n\n```python\n#usda 1.0\n(\nsubLayers = [\n\"shotFX.usd\",\n\"shotAnimationBake.usd\",\n\"sequence.usd\"\n]\n)\n```\n\nReferences:\n\n```python\n#usda 1.0\ndef \"MyPrim\"(\nreferences = [\n\"sequence.usd\"\n]\n)\n```\n\nRemember that each of the above methods serves different purposes and has its own strengths and weaknesses. You should choose based on the specific requirements of your project.\n\n",
        "validation_prompt": "When should I use a sublayer and a reference?"
      },
      {
        "prompts": [
          "What are Payloads?",
          "What are References?"
        ],
        "follow_up": "When should I use either of them?",
        "follow_up_context": "In USD, both Payloads and References are composition arcs that point to other layers, allowing objects from those layers to be pulled into the current scene graph. However, the two differ fundamentally in their loading and unloading capabilities and which composition arc you should use mainly depends on the specific requirements of your pipeline or project.\n\n\n- Payloads offer on-demand loading\/unloading capabilities, which means they can be attached to a Prim but not loaded immediately when the scene is being composed. Instead, Payloads can be specifically targeted for loading into the scene when required, allowing you to construct a \"working set\" of your scene that can be subsets of the entire scene as required. This allows for more efficient use of memory and can enhance the performance, especially for large scenes.\n\n- References, on the other hand, are always consumed greedily and are immediately loaded when the scene is being composed. This could be advantageous when all of the referenced assets must necessarily be in the scene at all times; however, it can also be a disadvantage in terms of performance for large scenes due to the lack of control over what gets loaded or unloaded.\n\n\nIn general, when dealing with very large scenes or when you need a level of control over the loading of complex or heavy data, Payloads are generally a better option. A typical use case for Payloads might be if you need to load only particular components of a model (e.g. the geometric representation but not the shading\/material data) for certain tasks. On the other hand, for smaller scenes or situations where all required data should always be present and loaded, References would typically be used.\n",
        "validation_prompt": "When should I use a payload and a reference?"
      }
    ],
    "test_basic_queries_code_based_follow_up": [
      {
        "prompts": [
          "What is a VtArray?",
          "Show implementation of its methods indexing, appending, removing, slicing, etc"
        ],
        "follow_up": "Show implementation of its methods indexing, appending, removing, slicing, etc",
        "validation_prompt": "Show implementation of its methods indexing, appending, removing, slicing, etc",
        "expected_output": "from pxr import Vt\n\nclass VtArrayExample:\n    def __init__(self):\n        self.array = Vt.IntArray([1, 2, 3])\n\n    def indexing(self):\n        print(\"\nIndexing:\")\n        print(self.array[0])  # prints 1\n        print(self.array[-1])  # prints 3\n\n    def appending(self):\n        print(\"\nAppending:\")\n        self.array = self.array + Vt.IntArray([4, 5, 6])\n        print(self.array)  # prints [1, 2, 3, 4, 5, 6]\n\n    def removing(self):\n        print(\"\nRemoving:\")\n        self.array = Vt.IntArray([x for x in self.array if x != 4])\n        print(self.array)  # prints [1, 2, 3, 5, 6]\n\n    def slicing(self):\n        print(\"\nSlicing:\")\n        print(self.array[1:3])  # prints [2, 3]\n        print(self.array[:3])  # prints [1, 2, 3]\n        print(self.array[1:])  # prints [2, 3, 5, 6]\n\n# Create a VtArrayExample\nvt_array_example = VtArrayExample()\n\n# Indexing\nvt_array_example.indexing()\n\n# Appending\nvt_array_example.appending()\n\n# Removing\nvt_array_example.removing()\n\n# Slicing\nvt_array_example.slicing()"
      }
    ],
    "test_code_generation_knowledge_follow_up": [
      {
        "prompts": [
          "Write python code to reset all primvar displayColors in a stage back to default values for all geometric prims"
        ],
        "follow_up": "What is GPrim in this code and why is it being used",
        "follow_up_context": "In the context of Pixar's Universal Scene Description (USD), a Gprim (short for \"Geometric Prim\") is a geometric primitive, which is a fundamental building block of a 3D scene. It represents a single geometric object, such as a sphere, cube, or mesh, that can be composed together to form more complex scenes.\r\n\r\nIn the code examples provided, a Gprim is typically created using the `UsdGeom` module, which provides classes for working with geometric primitives in USD. For example, `UsdGeom.Sphere` creates a sphere Gprim, while `UsdGeom.Cube` creates a cube Gprim.\r\n\r\nGprims are a key concept in USD, as they allow for the creation of complex scenes by combining multiple geometric objects. They can have various attributes, such as position, orientation, and scale, which can be manipulated using USD's API.",
        "validation_prompt": "What is GPrim and why is it used?"
      }
    ],
    "test_code_generation_code_follow_up": [
      {
        "prompts": [
          "Write python function that given a Usd.Prim object, get the bound material of that prim."
        ],
        "follow_up": "modify this code to return the shader of the material object",
        "validation_prompt": "Write a method to get the shader from a material object.",
        "expected_output": "```from pxr import Usd, UsdShade\n\ndef get_shader_of_material(material):\n    shader = None\n    for child in material.GetPrim().GetChildren():\n        if child.IsA(UsdShade.Shader):\n            shader = UsdShade.Shader(child)\n            break\n    return shader\n\n# Example usage:\nstage = Usd.Stage.CreateInMemory()\nmaterial = UsdShade.Material.Define(stage, '/MyMaterial')\nshader = get_shader_of_material(material)\nprint(shader)```"
      }
    ],
    "test_initial_setup": {
      "prompts": ["What are your functions?", "What are the features of USD file?"]
    }
  
}